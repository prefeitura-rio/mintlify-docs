---
title: Padr√µes para Cria√ß√£o de Queries para o Disparo
description: Este documento estabelece os padr√µes e melhores pr√°ticas para a cria√ß√£o de queries de disparo de mensagens via WhatsApp Business API.
---

# Padr√µes para Cria√ß√£o de Queries de Disparo WhatsApp

## 1. Introdu√ß√£o

Este documento estabelece os padr√µes e melhores pr√°ticas para a cria√ß√£o de queries de disparo de mensagens via WhatsApp Business API. O objetivo √© garantir a consist√™ncia, a qualidade dos dados, a conformidade com as pol√≠ticas de comunica√ß√£o do WhatsApp e a efici√™ncia dos envios, minimizando falhas e otimizando a experi√™ncia do usu√°rio.

### 1.1 Sequ√™ncia sugerida pr√©-disparo para o time da IPLAN

Esta sequ√™ncia detalha os passos essenciais para o time da IPLAN antes de qualquer disparo, focando em permiss√µes, configura√ß√µes de sistema e valida√ß√µes cruciais.

*   **Verificar se o agent "crm-registry-k8s" tem permiss√£o de leitura nas tabelas de origem da query:**
    *   **Explica√ß√£o:** O `crm-registry-k8s` √© o servi√ßo respons√°vel por acessar os dados que ser√£o utilizados na query. Sem as permiss√µes adequadas, a pipeline de disparo n√£o conseguir√° ler as tabelas necess√°rias, resultando em falha. Esta permiss√£o deve ser concedida a n√≠vel de projeto ou tabela espec√≠fica, garantindo o princ√≠pio do menor privil√©gio.
*   **Dar permiss√£o para o Service account `prefect-dbt@rj-iplanrio.iam.gserviceaccount.com` e `dbt-ci-github-rj-crm-registry@rj-crm-registry.iam.gserviceaccount.com`:**
    *   **Explica√ß√£o:** Este service account √© utilizado pelo Prefect e dbt para orquestra√ß√£o e transforma√ß√£o dos dados. √â fundamental que ele tenha permiss√£o para executar as transforma√ß√µes e gerar as tabelas intermedi√°rias e finais que alimentar√£o o processo de disparo.
*   **Validar se j√° existe um centro de custo para o √≥rg√£o cadastrado na plataforma da wetalkie:**
    *   **Explica√ß√£o:** A plataforma da Wetalkie organiza os disparos por centro de custo, o que √© crucial para o acompanhamento financeiro e a atribui√ß√£o correta das campanhas. Se o √≥rg√£o ainda n√£o tiver um centro de custo, ele precisar√° ser criado antes de prosseguir.
*   **Verificar se o usu√°rio "wetalkieapi@iplanrio.com" est√° atrelado a esse centro de custo:**
    *   **Explica√ß√£o:** Este usu√°rio √© a interface de comunica√ß√£o entre nossos sistemas e a Wetalkie. Ele deve estar devidamente associado ao centro de custo correto para que os disparos sejam contabilizados e gerenciados adequadamente.
*   **Adicionar IDs da HSM e outras informa√ß√µes na cria√ß√£o da tabela `rj-crm-registry.crm_whatsapp.mensagem_ativa` que est√° dentro de "queries_rj_crm_registry/models/core/dimensions/whatsapp/dim_whatsapp_mensagem_ativa" e rodar o "dbt run":**
    *   **Explica√ß√£o:** A `mensagem_ativa` √© a tabela que armazena os metadados das High-Supported Messages (HSM) aprovadas. √â aqui que os IDs √∫nicos das HSMs do WhatsApp s√£o registrados, juntamente com suas vari√°veis e detalhes. Ap√≥s adicionar as informa√ß√µes, fazer o merge com a master para que a tabela seja atualizada no BigQuery. J√° solicitamos √† Wetalkie uma API pr√≥pria para isso.
*   **Adicionar whitelist nessa [planilha](https://docs.google.com/spreadsheets/d/1g_l3wA2y1Xm1l6g_p4dJ2e_g_g_g_g_g_g_g_g_g_g/edit#gid=0) e avisar Bruno Almeida para rodar script:**

**Resumo dos passos:**


[ ] Testar query fornecida no BQ

[ ] Adicionar novos contatos na Whitelist

[ ] Pedir e aguardar Bruno Almeida rodar a libera√ß√£o dos contatos

[ ] Conferir se a URA Resposta est√° corretamente definida

[ ] Conferir ID HSM da mensagem a ser disparada

[ ] Conferir estado do Prefect

[ ] Aguardar sinal verde da Ingrid

[ ] Conferir URA e ID HSM novamente

[ ] Enviar disparos via prefect

### 1.2 Sequ√™ncia sugerida de pr√©-disparo para demais times

Esta se√ß√£o foca nas responsabilidades de outros times que criam as queries, garantindo a qualidade e conformidade dos dados de entrada.

*   **Verificar se a pessoa respons√°vel por escrever a query tem permiss√£o de leitura no projeto "rj-crm-registry". Se n√£o tiver, solicite √† Stella.**
    *   **Explica√ß√£o:** O projeto `rj-crm-registry` cont√©m as tabelas de dados mestre. Sem acesso de leitura, o desenvolvedor n√£o conseguir√° construir queries v√°lidas. A Stella √© o ponto de contato para solicita√ß√£o dessas permiss√µes.
*   **Verificar se a query est√° com todos os filtros necess√°rios para o disparo conforme o exemplo descrito nesta doc:**
    *   **Explica√ß√£o:** Queries bem filtradas s√£o essenciais para atingir o p√∫blico correto e evitar envios indesejados. Isso inclui filtros demogr√°ficos, de comportamento, de opt-in, entre outros, que devem ser alinhados com o objetivo da campanha.
*   **Verificar se foram selecionados apenas celulares cuja coluna "estrategia_envio" esteja como "ENVIAR" ou "TESTAR".**
    *   **Explica√ß√£o:** As demais categorias desta coluna t√™m um alto potencial de derrubar a qualidade do nosso n√∫mero de WhatsApp, afetando o disparo.
*   **Dar prefer√™ncia para disparar apenas para os casos em que estrategia_envio = "ENVIAR", use "TESTAR" caso a quantidade de n√∫meros a serem atingidos seja baixo ou devido √† urg√™ncia de notifica√ß√£o dessa pessoa.**
*   **Padronizar nomes das pessoas para primeiro nome apenas com a fun√ß√£o `FORMAT_NAME`:**
    *   **Explica√ß√£o:** Para mensagens personalizadas, √© comum usar apenas o primeiro nome para uma abordagem mais direta e menos formal. A fun√ß√£o `FORMAT_NAME` garante que essa padroniza√ß√£o seja aplicada de forma consistente.
*   **Trazer primeiro o nome_social e caso seja nulo o nome atrelado √†quele CPF:**
    *   **Explica√ß√£o:** Respeitar o nome social √© uma quest√£o de inclus√£o e conformidade. A query deve priorizar o `nome_social` e, apenas se este for nulo, utilizar o `nome` oficial associado ao CPF.
*   **Validar se a query retorna um objeto do tipo json com as chaves: `celular_disparo`, `externalID` e `vars`:**
    *   **Explica√ß√£o:** Esta √© a estrutura de sa√≠da obrigat√≥ria esperada pela pipeline de disparo. Qualquer diverg√™ncia causar√° falhas no processamento das mensagens. O formato JSON garante a flexibilidade para as vari√°veis das HSMs.

(exemplo da query no ponto 5. Exemplo de uso)

## 2. Padroniza√ß√£o de Dados

A padroniza√ß√£o dos dados √© fundamental para a qualidade e sucesso dos disparos, evitando falhas por dados inconsistentes ou inv√°lidos.

### 2.1 Limpeza e Padroniza√ß√£o de Telefone de Disparo

A correta formata√ß√£o dos n√∫meros de telefone √© um dos pontos mais cr√≠ticos para a entrega das mensagens no WhatsApp.

Caso a fonte do telefone n√£o esteja na tabela `rj-crm-registry.rmi_dados_mestres.pessoa_fisica` do RMI, √© necess√°rio realizar essa padroniza√ß√£o dos n√∫meros utilizando a fun√ß√£o `VALIDATE_AND_FORMAT_PHONE` criada dentro do `rj-crm-registry` e descrita abaixo. Se a fonte do telefone estiver dentro dessa tabela o telefone j√° est√° padronizado e essa etapa de valida√ß√£o e formata√ß√£o do telefone n√£o ser√° necess√°ria.

*   **Padronizar o n√∫mero de telefone para o qual ser√° realizado o disparo no formato 55DDD9xxxxXXXXX:**
    *   **Explica√ß√£o:** Este √© o formato internacional exigido pelo WhatsApp (DDI + DDD + N√∫mero). O DDI "55" √© para o Brasil, o DDD √© o c√≥digo de √°rea e o "9" √© para celulares (obrigat√≥rio em muitos DDDs).
*   **Verificar se o n√∫mero √© v√°lido utilizando a fun√ß√£o:**
    *   **Explica√ß√£o:** A fun√ß√£o `VALIDATE_AND_FORMAT_PHONE` n√£o apenas formata, mas tamb√©m verifica a validade do n√∫mero. Isso ajuda a eliminar n√∫meros inexistentes ou mal formatados antes do envio, reduzindo a taxa de falha.
*   **Se n√£o for v√°lido adicionar o n√∫mero 9 caso necess√°rio e o DDI 55:**
    *   **Explica√ß√£o:** A fun√ß√£o tenta corrigir n√∫meros que estejam pr√≥ximos do formato correto, adicionando o d√≠gito '9' para celulares e o DDI '55' caso estejam ausentes.
*   **Se o telefone original n√£o for v√°lido puxar o telefone alternativo do RMI:**
    *   **Explica√ß√£o:** Em caso de um n√∫mero principal inv√°lido, o sistema deve buscar um telefone alternativo dispon√≠vel no RMI (Registro Mestre de Informa√ß√µes) para tentar realizar o disparo. Isso maximiza as chances de contato.

**Fun√ß√£o:**

```sql
rj-crm-registry.udf.VALIDATE_AND_FORMAT_PHONE(phone_number: String) -> String
```

**Exemplos:**

```sql
rj-crm-registry.udf.VALIDATE_AND_FORMAT_PHONE('(21) 98888-8888') => '5521988888888'
rj-crm-registry.udf.VALIDATE_AND_FORMAT_PHONE('123') => Null (N√∫mero inv√°lido √© retornado como Nulo)
rj-crm-registry.udf.VALIDATE_AND_FORMAT_PHONE('(21) 3324-4233') => '5521933244233' (Adiciona o '9' para completar o formato de celular)
```

### 2.2 Limpeza e Padroniza√ß√£o de Telefone da Unidade de Atendimento

Quando o telefone de uma unidade (ex: escola, hospital, CRAS, Cl√≠nica da Fam√≠lia, etc) precisa ser exibido na mensagem, ele deve ter um formato amig√°vel para o usu√°rio.

Padronizar o telefone para o formato (21) xxxx-xxxx, nos casos em que temos que enviar o telefone da escola/CF/hospital etc...

**Fun√ß√£o:**

```sql
rj-crm-registry.udf.FORMAT_PHONE_DISPLAY(phone_number: String) -> String
```

Esta fun√ß√£o formata o n√∫mero para um padr√£o de exibi√ß√£o comum no Brasil.

**Exemplo:**

```sql
SELECT rj-crm-registry.udf.FORMAT_PHONE_DISPLAY("2133244233") => (21) 3324-4233
```

### 2.3 Limpeza e Padroniza√ß√£o de Nomes

A apresenta√ß√£o dos nomes na mensagem deve ser consistente e adequada ao contexto.

Padronizar o nome das pessoas/processos/exames/etc para ter a **primeira letra de cada palavra mai√∫scula**. Considerar no envio apenas o primeiro nome da pessoa.

**D√™ prefer√™ncia para** trazer primeiramente a coluna com o **nome social** e, caso este seja nulo, utilize a coluna de nome.

**Fun√ß√£o:**

```sql
rj-crm-registry.udf.FORMAT_NAME(input_name: STRING, first_only: BOOLEAN) -> String
```

*   **Explica√ß√£o:** Esta fun√ß√£o permite duas modalidades de padroniza√ß√£o:
    *   `first_only = True`: Retorna apenas o primeiro nome com a primeira letra mai√∫scula, ideal para sauda√ß√µes personalizadas.
    *   `first_only = False`: Retorna o nome completo, com a primeira letra de cada palavra em mai√∫scula (Title Case), √∫til para refer√™ncias formais ou nomes de processos.

**Exemplo:**

```sql
SELECT rj-crm-registry.udf.FORMAT_NAME('Joaquim Jos√© da Silva Xavier', True) => 'Joaquim'
SELECT rj-crm-registry.udf.FORMAT_NAME('Joaquim Jos√© da Silva Xavier', False) => 'Joaquim Jos√© da Silva Xavier'
```

## 3. Integra√ß√£o de Dados

A integra√ß√£o de dados envolve garantir que as mensagens sejam enviadas de forma inteligente e evitem a reincid√™ncia.

### 3.1 Remover telefones que j√° receberam aquela HSM (em manuten√ß√£o)

√â crucial evitar o envio repetido da mesma mensagem (HSM) para o mesmo contato, a fim de n√£o sobrecarregar o usu√°rio e manter a reputa√ß√£o do nosso n√∫mero.

Precisamos nos atentar para n√£o reenviar mensagens para n√∫meros que j√° receberam aquela HSM. Para evitar esse problema pode-se utilizar a tabela `rj-crm-registry.crm_whatsapp.telefone_disparado` que cont√©m dados do id_hsm, do telefone para qual o disparo aconteceu e todas as datas em que houve disparo para ele.

*   **Explica√ß√£o:** A tabela `rj-crm-registry.crm_whatsapp.telefone_disparado` atua como um hist√≥rico de envios. Ao cruzar a lista de contatos para o novo disparo com esta tabela, podemos filtrar e remover aqueles que j√° receberam a HSM espec√≠fica em quest√£o, controlando a frequ√™ncia de comunica√ß√£o. Esta funcionalidade, atualmente "em manuten√ß√£o", ser√° vital para a governan√ßa de comunica√ß√£o.

## 4. Especifica√ß√µes obrigat√≥rias na query

Para que a pipeline de disparo funcione corretamente, a query final que alimenta o sistema deve seguir um formato rigoroso.

### 4.1 Coluna com o n√∫mero de telefone a ser disparado DEVE SER NOMEADA CELULAR_DISPARO

A coluna contendo o n√∫mero de telefone do destinat√°rio deve ter um nome espec√≠fico para ser reconhecida pelo sistema.

*   **Explica√ß√£o:** O sistema de disparo √© configurado para ler especificamente a coluna `CELULAR_DISPARO`. Qualquer outro nome resultar√° em falha. Esta padroniza√ß√£o √© inegoci√°vel.

### 4.2 Deve existir uma coluna com nome externalID (external ID tudo junto) com o n√∫mero de CPF da pessoa

A coluna `externalID` (contendo o CPF) serve como um identificador √∫nico para cada destinat√°rio. Isso permite associar o disparo a uma pessoa espec√≠fica, facilitando a an√°lise de performance das campanhas, a identifica√ß√£o de problemas (como n√∫meros de telefone desatualizados) e a conformidade com a LGPD.

Esse campo √© imprescind√≠vel para conseguirmos analisar de forma f√°cil os disparos e tentar identificar se esse telefone de fato pertence a essa pessoa.

### 4.3 Outras colunas devem ter o mesmo nome que os definidos na mensagem ativa (HSM)

As vari√°veis personalizadas dentro da mensagem devem corresponder exatamente aos nomes das colunas na query.

Suponha a seguinte mensagem ativa a ser disparada:

> Ol√°, @NOME! Tudo bem? <br/>
> <br/>
> Este √© o novo canal oficial de comunica√ß√£o da *Prefeitura do Rio* aqui no WhatsApp. <br/>
> <br/>
> Seguem as informa√ß√µes do seu agendamento do Cad√önico: <br/>
> <br/>
> Local: @LOCAL. üìç <br/>
> Dia: @DATA. üìÖ  <br/>
> Hor√°rio: @HORA. ‚è∞ <br/>
> Endere√ßo: @ENDERECO. üìç <br/>
> Telefone do CRAS: @TELEFONE_CRAS. üìç <br/>
> <br/>
> Voc√™ confirma a sua presen√ßa?


| Par√¢metros |
| :--- |
| @NOME |
| @LOCAL |
| @DATA |
| @HORA |
| @TELEFONE_CRAS |

Para acontecer o disparo precisamos informar os campos "nome", que representa o primeiro nome da pessoa, "local" (local em que acontecer√° o atendimento), "data" no formato dd/mm/aaaa, "hora" no formato hh:mm e telefone do CRAS no formato (DDD) xxxx-xxxx. Nesse caso, precisamos que a query retorne as colunas com os seguintes nomes e formatos obrigatoriamente:

| Coluna da query | Descri√ß√£o | Formato esperado | Fun√ß√£o dispon√≠vel |
| :--- | :--- | :--- | :--- |
| celular_disparo | Celular para o qual ser√° feito o disparo | DDIDDD9xXXXXXXX (5521981245077) (obrigat√≥rio) | VALIDATE_AND_FORMAT_PHONE |
| externalID | N√∫mero do CPF | String de 11 d√≠gitos  (obrigat√≥rio)| |
| nome | Nome da pessoa que tem o agendamento | Capitalizado | FORMAT_NAME|
| local | Local do agendamento, de prefer√™ncia com endere√ßo | Title case - cada primeira letra da palavra em mai√∫sculo (preferencialmente) | |
| data | Data do agendamento | DD/MM/AAAA (preferencialmente) | |
| hora | Hora do agendamento | HH:MM | |
| telefone_cras | Telefone da unidade | (21) 3524-5441 | FORMAT_PHONE_DISPLAY |

**Explica√ß√£o:** Esta tabela detalha a correspond√™ncia exata entre os placeholders (vari√°veis) definidos na HSM e os nomes das colunas que a query deve retornar. Se a HSM espera um placeholder `@NOME`, a query deve ter uma coluna chamada `nome`. Al√©m do nome, o formato dos dados tamb√©m √© crucial (e.g., data no formato `DD/MM/AAAA`), pois o sistema de disparo n√£o far√° convers√µes complexas.

### 4.4 Estrutura da sa√≠da final da query

A query final deve encapsular os dados em um **objeto JSON** espec√≠fico para facilitar o processamento pela API do WhatsApp.

A query que ser√° executada dentro da pipeline de disparo de mensagens de WhatsApp deve receber somente os campos necess√°rios para a HSM desejada, com as vari√°veis espec√≠ficas de cada HSM localizadas como colunas dentro do campo "vars", como no exemplo abaixo.

**Sobre o struct "vars", √© importante ressaltar que os campos que ele cont√©m devem ser nomeados com os mesmos nomes cadastrados na HSM da WeTalkie, diverg√™ncias de nome n√£o s√£o aceitas e resultar√£o em falhas nos disparos.**

Os campos suportados s√£o:

*   `"celular_disparo"`: n√∫mero de telefone alvo do disparo.
*   `"externalID"`: n√∫mero de CPF do alvo do disparo.
*   `"vars"`: struct que cont√©m dados de colunas vari√°veis.

**Exemplo de query:**

**Quest√£o:** Como enviar um disparo para uma HSM que espera receber os campos "@NOME", "@LOCAL", "@DATA", "@HORA", @TELEFONE_CRAS.

**Resposta:**

```sql
SELECT
    TO_JSON_STRING(
        STRUCT(
            telefone_formatado AS celular_disparo,
            cpf AS externalID,
            STRUCT(
                nome,
                local,
                data,
                hora,
                telefone_cras
            ) AS vars
        )
    ) AS destination_data
FROM
    pessoa_fisica AS pf
```

Este exemplo demonstra como construir a estrutura JSON de sa√≠da. Note que `telefone_formatado` e `cpf` s√£o mapeados para `celular_disparo` e `externalID` respectivamente. As vari√°veis da HSM (`nome`, `local`, `data`, `hora`, `telefone_cras`) s√£o agrupadas dentro do `STRUCT` nomeado `vars`. O `TO_JSON_STRING` converte este `STRUCT` em uma representa√ß√£o JSON string que a API da Wetalkie pode consumir.

## 5. Exemplo de uso

Este √© um exemplo pr√°tico de uma query completa, incorporando as melhores pr√°ticas e fun√ß√µes de padroniza√ß√£o discutidas.

**Exemplo com**

*   principais filtros
*   uso das fun√ß√µes criadas
*   criar estrutura de json com os nomes obrigat√≥rios das chaves

```sql
WITH base AS (
    SELECT
        `rj-crm-registry.udf.FORMAT_NAME`(COALESCE(nome_social, nome), TRUE) AS primeiro_nome, -- traz o nome social caso houver
        `rj-crm-registry.udf.VALIDATE_AND_FORMAT_CELLPHONE`(
            CONCAT(
                IFNULL(telefone.principal.ddi, "55"),
                IFNULL(telefone.principal.ddd, "21"),
                telefone.principal.valor
            )
        ) AS celular_disparo,
        cpf AS externalID,
        assistencia_social.cras.nome AS cras
    FROM
        `rj-crm-registry.rmi_dados_mestres.pessoa_fisica`
    WHERE
        telefone.indicador = TRUE
        AND obito.indicador = FALSE
        AND menor_idade = FALSE
        AND (nome IS NOT NULL OR nome_social IS NOT NULL)
        AND telefone.principal.estrategia_envio IN ("ENVIAR", "TESTAR")
        AND endereco.principal.municipio = "Rio de Janeiro" -- avaliar necessidade desse filtro em cada caso pq muitas vezes o campo endereco √© nulo
        AND DATE_DIFF(CURRENT_DATE("America/Sao_Paulo"), DATE(telefone.principal.datahora_ultima_leitura), DAY) > 3 -- n√£o enviar disparo para quem recebeu hsm nos ultimos x dias (opcional)
)
SELECT
    -- celular_disparo, externalId e vars s√£o nomes obrigat√≥rios no retorno dessa query
    -- outros valores importantes devem ter exatamente o mesmo nome do par√¢metro definido na mensagem ativa (hsm) e devem estar dentro de vars
    -- nesse caso, a mensagem ativa exige os par√¢metros "NOME" e "CRAS"
    TO_JSON_STRING(
        STRUCT(
            externalID,
            celular_disparo,
            STRUCT(
                primeiro_nome AS NOME,
                cras AS CRAS
            ) AS vars
        )
    )
FROM
    base
```

*   **Explica√ß√£o Detalhada do Exemplo:**
    *   **CTE base:** Esta Common Table Expression (CTE) prepara os dados brutos, aplicando as fun√ß√µes de padroniza√ß√£o e os filtros essenciais.
        *   `FORMAT_NAME(COALESCE(nome_social, nome), TRUE)`: Prioriza o `nome_social` e, se nulo, usa o `nome`, retornando apenas o primeiro nome capitalizado. `COALESCE` garante que um valor n√£o nulo seja sempre selecionado entre `nome_social` e `nome`.
        *   `VALIDATE_AND_FORMAT_CELLPHONE(CONCAT(IFNULL(telefone.principal.ddi, "55"), IFNULL(telefone.principal.ddd, "21"), telefone.principal.valor))`: Concatena DDI (com default "55"), DDD (com default "21") e o valor do telefone, depois valida e formata o celular. `IFNULL` √© crucial para evitar que valores nulos no DDI/DDD resultem em uma string de telefone vazia ou inv√°lida.
        *   `cpf AS externalID`: Mapeia a coluna `cpf` para o nome obrigat√≥rio `externalID`.
        *   `assistencia_social.cras.nome AS cras`: Seleciona o nome do CRAS para ser usado como uma vari√°vel na HSM.
    *   **Cl√°usula WHERE:**
        *   `telefone.indicador = TRUE`: Garante que apenas telefones considerados principais e v√°lidos sejam selecionados.
        *   `obito.indicador = FALSE`: Filtra pessoas que n√£o est√£o em √≥bito.
        *   `menor_idade = FALSE`: Garante que apenas maiores de idade sejam contatados.
        *   `(nome IS NOT NULL OR nome_social IS NOT NULL)`: Garante que a pessoa tenha um nome v√°lido.
        *   `telefone.principal.estrategia_envio IN ("ENVIAR", "TESTAR")`: Filtra pela estrat√©gia de envio, conforme explicado na se√ß√£o 1.2.
        *   `endereco.principal.municipio = "Rio de Janeiro"`: Exemplo de filtro geogr√°fico; √© opcional e deve ser avaliado caso a caso.
        *   `DATE_DIFF(CURRENT_DATE("America/Sao_Paulo"), DATE(telefone.principal.datahora_ultima_leitura), DAY) > 3`: Exemplo de filtro para evitar reenvios recentes para a mesma pessoa (ou para quem recebeu qualquer HSM nos √∫ltimos X dias, dependendo da interpreta√ß√£o do campo `datahora_ultima_leitura`).
    *   **SELECT final:** Constr√≥i o JSON de sa√≠da.
        *   `TO_JSON_STRING(STRUCT(...))`: Converte o struct interno em uma string JSON.
        *   `STRUCT(externalID, celular_disparo, STRUCT(primeiro_nome AS NOME, cras AS CRAS) AS vars)`: Cria o objeto `STRUCT` com os campos obrigat√≥rios `externalID` e `celular_disparo` diretamente, e um `STRUCT` aninhado para `vars`, onde as vari√°veis da HSM (NOME, CRAS) s√£o mapeadas dos campos `primeiro_nome` e `cras` da CTE `base`.

## 6. Gloss√°rio de Terminologia para Disparos via WhatsApp Business

Esta se√ß√£o define os principais termos t√©cnicos utilizados no contexto de disparos de mensagens via WhatsApp Business API, fornecendo um entendimento comum para todos os envolvidos.

### 6.1 Mensagem Ativa (HSM - High-Supported Message)


As HSMs s√£o a base da comunica√ß√£o proativa no WhatsApp Business. Elas precisam ser submetidas e aprovadas pelo WhatsApp antes de serem enviadas. Sua estrutura cont√©m placeholders (vari√°veis como `@NOME`, `@DATA`) que s√£o preenchidos dinamicamente pela query.

S√£o usadas para comunica√ß√µes oficiais, como notifica√ß√µes, alertas e transa√ß√µes e enviadas de forma proativa pela empresa ao cliente. .


### 6.2 Mensagem Receptiva (URA)

Diferente das HSMs, as Mensagens Receptivas s√£o respostas a uma intera√ß√£o iniciada pelo cliente. 

Elas podem iniciar-se por resposta a uma mensagem ativa enviada pela empresa ou de forma indenpendente quando o cliente envia alguma mensagem para o n√∫mero de whatsapp da Prefeituras. Aqui inicia-se o uso das URAs que s√£o desenvolvidas dentro da plataforma do broker.

### 6.3 Disparo

Processo de envio em massa de mensagens ativas (HSM) para uma lista de destinat√°rios.

### 6.4 Falha

Ao realizarmos os disparos podemos nos deparar com alguns erros que impedem a entrega de uma mensagem. Eles podem ocorrer por:


*   **N√∫mero inv√°lido:** N√£o registrado no WhatsApp ou inexistente. Ou seja, o n√∫mero de telefone fornecido n√£o est√° ativo no WhatsApp ou n√£o existe na rede de telefonia. Isso pode ser mitigado com a fun√ß√£o `VALIDATE_AND_FORMAT_PHONE`.
*   **Limite de taxa excedido:** O WhatsApp imp√µe limites na quantidade de mensagens que uma empresa pode enviar em um determinado per√≠odo. Exceder esses limites leva a falhas. √â essencial gerenciar o volume de disparos e a reputa√ß√£o do n√∫mero.
*   **Bloqueio:** O cliente bloqueou o n√∫mero da empresa, optou por n√£o receber mais mensagens ou o n√∫mero est√° em uma lista de exclus√£o interna. Enviar para esses contatos √© contra as pol√≠ticas e danifica a reputa√ß√£o.
*   **Template rejeitado:** Mensagem fora do padr√£o aprovado pelo WhatsApp. Houve uma tentativa de enviar uma mensagem que n√£o corresponde a uma HSM pr√©-aprovada, ou as vari√°veis foram preenchidas de forma incorreta, fazendo com que o template se descaracterize.

## 7. Permiss√µes

A gest√£o de permiss√µes √© um pilar de seguran√ßa e funcionalidade, garantindo que apenas entidades autorizadas acessem e manipulem os dados.

Para rodar os disparos via Prefect precisamos de acesso √†s tabelas para o agent "crm-registry-k8s". Pode-se criar uma view dos dados do disparo e fornecer permiss√£o apenas √† ela.

√ìrg√£o/ Secretaria deve nos enviar o usu√°rio do GCP que criar√° as queries para liberarmos acesso de "EDRio - leitor" em:

*   `rj-crm-registry.rmi_dados_mestres.pessoa_fisica`
*   `rj-crm-registry.udf`

## 8. Cuidados

Esta se√ß√£o destaca armadilhas comuns e como evit√°-las ao criar queries.

### 8.1 Concatena√ß√£o de colunas

A concatena√ß√£o de strings, especialmente para n√∫meros de telefone e endere√ßos, exige aten√ß√£o aos valores nulos.

Cuidado com nulls nas colunas do RMI de DDI e DDD, procure sempre utilizar a fun√ß√£o `IFNULL` quando necessitar concatenar colunas. O mesmo vale para concatena√ß√£o de endere√ßos.

*   **Explica√ß√£o:** A fun√ß√£o `CONCAT` em SQL pode retornar `NULL` se qualquer uma das colunas que est√£o sendo concatenadas for `NULL`. Isso √© um problema cr√≠tico para n√∫meros de telefone. Usar `IFNULL(coluna, 'valor_default')` garante que, se uma coluna for `NULL`, um valor padr√£o (como "55" para DDI ou "21" para DDD) ser√° utilizado, evitando que o resultado da concatena√ß√£o seja `NULL` e, consequentemente, que o telefone se torne inv√°lido.

**Ex:** `CONCAT(IFNULL(telefone.principal.ddi, "55"), IFNULL(telefone.principal.ddd, "21"), telefone.principal.valor) AS celular_disparo`

### 8.2 Cl√°usula WHERE

A aplica√ß√£o correta de filtros na cl√°usula `WHERE` √© fundamental para a segmenta√ß√£o e a conformidade dos disparos.

Ao usar a tabela `pessoa_fisica`, procure filtrar apenas pessoas vivas, maiores de idade e que possuem a coluna de indicador de telefone principal como true

*   **Explica√ß√£o:** Estes s√£o filtros b√°sicos e essenciais para a maioria das campanhas:
    *   `telefone.indicador = TRUE`: Garante que pelo menos um n√∫mero de telefone existe.
    *   `obito.indicador = FALSE`: Evita o contato com pessoas falecidas.
    *   `menor_idade = FALSE`: Garante que apenas adultos sejam contatados, respeitando a legisla√ß√£o e as pol√≠ticas de comunica√ß√£o com menores.

```sql
WHERE telefone.indicador = TRUE AND obito.indicador = FALSE AND menor_idade = FALSE
```
